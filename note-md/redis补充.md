# Redis事务

在 Redis 中，事务通过 `MULTI`、`EXEC`、`DISCARD` 和 `WATCH` 四个命令来实现。Redis 的事务允许以原子方式执行一系列命令，这意味着这些命令要么全部执行成功，要么一个也不执行。

- **MULTI**：标记事务的开始。之后的所有命令将不会立即执行，而是被放入队列中。
- **EXEC**：执行所有在 `MULTI` 后面入队的命令，并且以原子的方式执行。如果在这个过程中有命令出错，则其他命令仍然会被执行，但是错误的命令不会被执行。
- **DISCARD**：清除队列中的所有命令，并退出事务状态。
- **WATCH**：用于检测键是否被修改。如果在 `WATCH` 之后和 `EXEC` 之前，某个被 WATCH 的键被修改了，那么整个事务将会失败（即 `EXEC` 返回空响应）。可以使用**UNWATCH**取消

Redis 事务不支持回滚机制，这意味着一旦事务中的命令开始执行，即使后续命令出现错误，之前的命令也不会被撤销。



Redis事务和MySQL事务的区别：

1. **原子性**
   - **Redis**: Redis 事务不具备真正的原子性，虽然事务内的命令会按顺序执行，但如果某些命令失败，其他命令依然会执行，不会自动回滚。
   - **MySQL**: MySQL 事务具有完全的原子性，要么所有命令都成功，要么全部失败并回滚。
2. **隔离性**
   - **Redis**: Redis 提供了简单的隔离级别，通过 `WATCH` 可以监控某些键的变化，防止并发冲突，但并没有复杂的隔离级别如读未提交、读已提交等。
   - **MySQL**: MySQL 支持多种事务隔离级别（读未提交、读已提交、可重复读、串行化），可以根据需求调整隔离级别来控制并发访问的行为。
3. **持久性**
   - **Redis**: 持久化依赖于配置，如 RDB 快照或 AOF 日志，但默认情况下并不是每次写操作都会同步到磁盘上。
   - **MySQL**: 事务提交后，更改会被立即写入日志文件，并根据配置决定何时刷盘，通常来说，MySQL 更注重数据的持久性和安全性。
4. **回滚机制**
   - **Redis**: 不支持回滚，一旦事务开始执行，即使中途出错，已完成的部分也会保留。
   - **MySQL**: 完全支持事务回滚，可以在任何时候撤销尚未提交的更改。



**redis事务错误类型：**

- 用MULTI开启事务后，输入的命令有误，在此命令回车后立即报错。再执行exec所有命令都无法执行。
- 输入命令时错误并没有发现（语法没有问题，比如自增了一个字符串类型的值）。使用exec执行命令了才发现错误，此时执行成功的命令不会回滚，执行错误的会报错。





Redis使用Watch来提供乐观锁定，类似于CAS（Check-and-Set）。

先使用Watch监视key，再开启MULTI，在MULTI和EXEC期间如果key发生改变，则此事务所有命令都失败

exec后，所有watch取消；当客户端连接丢失（比如退出连接），也会取消监视



# BigKey

## MoreKey

**问题：**

如何遍历海量数据？keys *可以吗？

-- 建议禁用keys *，由于redis单线程，keys复杂度为O（n），如果key过多，使用此命令会造成Redis阻塞，可能引起缓存雪崩甚至数据库宕机

此外flushdb / flushall等命令也应限制或禁用

（注意：如果持久化文件中有要禁用的命令，可能导致redis启动失败，应先删除这些命令或者删除持久化文件）



那么keys *用不了，应该用什么呢？

--scan、sscan、hscan、zscan等



`scan cursor [match pattern] [count count]`

cursor：游标

pattern：匹配的模式

count：指定从数据集里返回多少元素，默认值为10



scan命令是一个基于游标的迭代器，每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为scan命令的游标参数。

scan返回包含两个元素的数组，第一个元素是用于进行下一次迭代的新游标；第二个元素则是一个数组，这个数组包含了元素。如果新游标返回0，代表迭代已达到末尾。

scan的遍历顺序非常特别，它不是从第零位一直遍历到末尾，而是采用了高位进位加法来遍历。之所以使用这样的特殊方式进行遍历，是考虑到字典的扩容和缩容造成传统游标的改变。具体原理：

```
假设哈希表的大小为 8（即有 8 个槽位，编号为 0 到 7）。我们通过高位进位加法计算游标的变化过程：

初始状态
当前游标值 c = 0（二进制 0b000）。
第一次迭代
找到最高有效位：c = 0，没有有效位。
加1：将最低有效位设为1，得到新的游标值 c = 1（二进制 0b001）。
第二次迭代
找到最高有效位：c = 1（二进制 0b001），最高有效位是第0位。
加1：将第0位加1，得到新的游标值 c = 2（二进制 0b010）。
第三次迭代
找到最高有效位：c = 2（二进制 0b010），最高有效位是第1位。
加1：将第1位加1，得到新的游标值 c = 4（二进制 0b100）。
第四次迭代
找到最高有效位：c = 4（二进制 0b100），最高有效位是第2位。
加1：将第2位加1，得到新的游标值 c = 0（二进制 0b000，溢出后回绕到0）。
总结
完整的游标变化序列是：0 -> 1 -> 2 -> 4 -> 0。

4. 为什么高位进位加法能避免重复和遗漏？
(1) 均匀分布
高位进位加法生成的游标序列并不是简单的线性递增，而是基于二进制的高位优先规则，这使得游标的变化更加随机化且均匀分布在整个哈希表的索引空间中。即使哈希表发生扩容或缩容，这种均匀分布的特性仍然能够保证每个槽位被访问一次且仅一次。

(2) 动态调整兼容性
扩容：当哈希表扩容时，新的槽位数量是原来的两倍，Redis 会将旧槽位中的元素重新分配到新槽位中。高位进位加法的游标变化模式天然适应这种变化，因为它总是基于当前哈希表的大小进行计算。
缩容：当哈希表缩容时，槽位数量减少一半，但高位进位加法的游标计算方式仍然能够正确映射到新的槽位范围。
```



## BigKey（在最佳实践笔记中已提到）



## BigKey生产调优

在 Redis 中，Bigkey 的处理和调优是一个重要的运维任务，尤其是在高并发场景下。Redis 提供了一些机制来优化 Bigkey 的删除操作，其中 **Lazy Free** 是一个关键的特性。它通过异步释放内存的方式减少对 Redis 主线程的影响，从而避免阻塞问题。

以下是关于 Bigkey 调优和 Lazy Free 的详细解析：



**1. 什么是 Lazy Free？**

**Lazy Free** 是 Redis 提供的一种机制，用于异步释放键占用的内存。它的核心思想是将资源释放的操作从主线程中移出，交给后台线程执行，从而避免阻塞 Redis 的主线程。

- **适用场景**：主要用于删除 Bigkey 或者需要大量时间来释放内存的操作。

- 优点

  - 避免 Redis 主线程被阻塞。
- 提高 Redis 的响应速度和吞吐量。



**2. Lazy Free 的实现原理**

Redis 的 Lazy Free 机制依赖于以下两个核心组件：

1. **引用计数**：Redis 使用引用计数来管理对象的生命周期。当一个对象的引用计数降为 0 时，表示该对象不再被使用，可以安全地释放。
2. **后台线程池**：Redis 在内部维护了一个或多个后台线程（默认是单线程），用于执行异步的内存释放操作。

工作流程

1. 当调用 `UNLINK` 或启用 Lazy Free 特性时，Redis 会将目标键从数据库的数据结构中移除，并将其标记为“待释放”状态。
2. 后台线程池接管这些“待释放”的对象，并逐步释放它们占用的内存。
3. 主线程无需等待内存释放完成，直接返回结果给客户端。



**3. Lazy Free 的配置**

Redis 提供了几个配置选项来控制 Lazy Free 的行为。这些选项可以通过修改 `redis.conf` 文件或者在运行时使用 `CONFIG SET` 命令动态调整。

**(1) lazyfree-lazy-eviction**

- **作用**：是否在内存不足时（触发淘汰策略）启用 Lazy Free。
- **默认值**：`no`
- **建议**：如果 Redis 实例中存在大量大键，建议开启此选项以避免淘汰操作导致的阻塞。

**(2) lazyfree-lazy-expire**

- **作用**：是否在过期键被删除时启用 Lazy Free。
- **默认值**：`no`
- **建议**：如果设置了 TTL 的键较大，建议开启此选项。

**(3) lazyfree-lazy-server-del**

- **作用**：是否在服务器端显式删除键时（如 `RENAME`、`FLUSHDB` 等命令）启用 Lazy Free。
- **默认值**：`no`
- **建议**：如果频繁执行这些命令并涉及大键，建议开启此选项。

**(4) replica-lazy-flush**

- **作用**：是否在从节点执行全量同步后的 `FLUSHALL` 或 `FLUSHDB` 操作时启用 Lazy Free。
- **默认值**：`no`
- **建议**：如果从节点数据量较大，建议开启此选项。



**4. 如何启用 Lazy Free？**

Lazy Free 功能可以通过以下两种方式启用：

**(1) 修改配置文件**

在 `redis.conf` 文件中添加或修改以下配置项：

```
lazyfree-lazy-eviction yes
lazyfree-lazy-expire yes
lazyfree-lazy-server-del yes
replica-lazy-flush yes
```

**(2) 动态设置**

使用 `CONFIG SET` 命令动态调整配置：

```
CONFIG SET lazyfree-lazy-eviction yes
CONFIG SET lazyfree-lazy-expire yes
CONFIG SET lazyfree-lazy-server-del yes
CONFIG SET replica-lazy-flush yes
```



**5. 使用 UNLINK 替代 DEL**

`UNLINK` 是 Redis 提供的一个命令，专门用于异步删除键。它是 Lazy Free 的典型应用场景。

**示例**

假设有一个 Bigkey `bigkey`，你可以使用以下命令异步删除它：

```
UNLINK bigkey
```

与 `DEL` 不同，`UNLINK` 不会阻塞 Redis 主线程，而是将删除操作交给后台线程执行。



**6. 分批删除 Bigkey**

对于包含大量元素的数据结构（如 `List`、`Set`、`Hash` 或 `Sorted Set`），可以直接使用分批删除的方式来避免一次性删除带来的性能问题。

**示例**

(1) 分批删除 Hash 的字段

```
# 每次删除 100 个字段
HSCAN bigkey 0 COUNT 100
HDEL bigkey field1 field2 ... field100
```

(2) 分批删除 List 的元素

```
# 每次弹出 100 个元素
LPOP bigkey 100
```

(3) 分批删除 Set 的成员

```
# 每次随机移除 100 个成员
SPOP bigkey 100
```

(4) 分批删除 Sorted Set 的成员

```
# 每次移除最小的 100 个成员
ZPOPMIN bigkey 100
```



**7. 监控和检测 Bigkey**

为了有效管理 Bigkey，定期监控和检测是非常重要的。

**(1) 使用 redis-cli --bigkeys**

Redis 提供了一个内置工具 `--bigkeys` 来扫描数据库并报告 Bigkey。

```
redis-cli --bigkeys
```

**(2) 使用 MEMORY USAGE**

可以使用 `MEMORY USAGE` 命令查看某个键占用的内存量。

```
MEMORY USAGE bigkey
```

**(3) 使用 Redis 模块**

一些 Redis 模块（如 [RedisGears](https://redis.io/modules/redisgears/) 或 [RedisInsight](https://redis.com/redis-enterprise/redis-insight/)）提供了更强大的功能来分析和处理 Bigkey。



**8. 总结**

通过结合 **Lazy Free** 和其他优化手段，可以有效管理和优化 Bigkey，从而提升 Redis 的性能和稳定性。以下是具体建议：

1. **启用 Lazy Free**：根据业务需求调整相关配置选项（如 `lazyfree-lazy-eviction` 和 `lazyfree-lazy-expire`）。
2. **使用 UNLINK 替代 DEL**：尽量避免直接使用 `DEL` 删除大键，改用 `UNLINK`。
3. **分批删除**：对于复杂数据结构，采用分批删除的方式逐步清理数据。
4. **定期检测 Bigkey**：使用 `redis-cli --bigkeys` 或其他工具定期检查和优化 Bigkey。

通过这些方法，可以显著减少 Bigkey 对 Redis 性能的影响，确保系统的高效运行。





# 布隆过滤器

## 概述

- 布隆过滤器（Bloom Filter）是一种空间效率非常高的概率型数据结构，主要用于判断一个元素是否在一个集合中。它能够快速地告诉你某个元素“可能在集合中”或“绝对不在集合中”。布隆过滤器通过允许一定程度的误报（即报告某个元素可能存在但实际上不存在的情况），以换取极低的存储需求和高效的查询速度。

  **布隆过滤器的工作原理**

  1. **初始化**：创建一个长度为 m 的位数组，并将其所有位初始化为 0。
  2. **哈希函数**：选择 k 个独立的哈希函数，这些哈希函数将输入元素映射到位数组的不同位置上。
  3. 插入元素
     - 当要向布隆过滤器中添加一个元素时，使用这 k个哈希函数对该元素进行哈希计算，得到 k个不同的哈希值。
     - 将这些哈希值对应到位数组的位置上的位设置为 1。
  4. 查询元素
     - 要检查一个元素是否存在于布隆过滤器中，同样使用这 k 个哈希函数对该元素进行哈希计算并取模得到k个位。
     - 如果所有对应的位都是 1，则该元素可能存在于集合中；如果有任何一个位是 0，则该元素绝对不在集合中。

  **主要特点**

  - **空间高效**：相比直接存储元素，布隆过滤器只需要少量的位来表示大量元素的存在情况。
  - **时间高效**：无论是插入还是查询操作的时间复杂度均为 O(k)，其中 k 是哈希函数的数量，通常是一个小常数。
  - **存在误报率**：布隆过滤器可能会错误地认为一个不在集合中的元素存在于集合中，但不会漏报（即将存在的元素报告为不存在）。
  - **无法删除元素**：由于多个元素可能共享同一个位，因此不能简单地通过将位重置为 0 来实现删除操作。

<img src="../assets/屏幕截图 2025-04-12 211126-1745051720953.png" alt="屏幕截图 2025-04-12 211126" style="zoom:75%;" />

​	布隆过滤器优点：内存占用少，没有多余key

​	缺点：

		- 实现复杂
	
		- 存在误判可能（因为哈希函数本身就是散列函数，可能会有碰撞）
		- 不能删除元素



## 原理&使用场景

哈希碰撞：输出值相同，输入值不一定相同；输出值不同，输入值一定不同。

如果只用一个哈希函数，很容易发生哈希碰撞。



建议：

- 使用时不要让实际元素数量远大于初始化bitmap的位数
- 当实际元素数量超过初始化数量时，应该对布隆过滤器进行重建，创建一个更大的过滤器，再将所有历史元素批量add进行



**使用场景:**

由于“有不一定有，无一定无”，场景为：

- 放在redis前解决缓存穿透问题
- 黑名单校验，识别垃圾邮件
- 存放安全连接网址，访问时如果不在过滤器里则不允许访问。





# 布谷鸟过滤器

**1. 基本原理**

布谷鸟过滤器基于**布谷哈希（Cuckoo Hashing）**技术。其核心思想是利用两个哈希函数来确定元素可以放置的位置，并通过“踢出”机制解决冲突问题。每个元素的指纹（fingerprint）被存储在一个或另一个位置上，如果这两个位置都已满，则会随机选择一个位置的元素进行替换并尝试将其重新定位到它的另一个可能位置。



**主要组成部分**

- **桶（Bucket）**：布谷鸟过滤器的基本存储单元，通常每个桶可以存储多个指纹。
- **指纹（Fingerprint）**：每个元素通过哈希计算得到的一个较短的二进制串，用来代表该元素。
- **哈希函数**：使用两个独立的哈希函数生成两个不同的索引位置。



**2. 工作流程**

**（1）插入**

1. 对于要插入的元素，首先计算其两个哈希值，从而确定两个可能的桶位置。
2. 检查这两个位置是否有一个未满。如果有，则将该元素的指纹插入其中。
3. 如果两个位置都满了，则随机选择一个位置的现有指纹进行“踢出”，并将新元素的指纹放入这个位置。
4. 被踢出的指纹需要根据其自身的哈希值找到新的位置，并重复上述过程。
5. 如果经过多次尝试后仍无法完成插入（达到最大迭代次数），则认为过滤器已满，可能需要扩展容量或调整参数。

**（2）查找**

1. 计算待查找元素的两个哈希值。
2. 检查对应的两个桶中是否有匹配的指纹存在。
3. 如果任何一个桶中找到了匹配的指纹，则认为该元素可能存在；否则，确认该元素不存在。

**（3）删除**

1. 同样计算元素的两个哈希值。
2. 在对应的两个桶中寻找匹配的指纹。
3. 找到后直接从桶中移除该指纹即可。



- **指纹长度的影响**：布谷鸟过滤器中使用的指纹长度是一个关键因素。较短的指纹意味着更高的碰撞几率，从而导致较高的误报率。相反，较长的指纹虽然降低了误报率，但增加了存储开销。
- **负载因子**：布谷鸟过滤器的性能和误报率还受其负载因子（即填充程度）的影响。高负载因子可能导致更多的踢出操作，进而增加误报的可能性。









































































